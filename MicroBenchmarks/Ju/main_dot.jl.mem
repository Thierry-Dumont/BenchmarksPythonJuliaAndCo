        - 
        - # initalize an array
        - function Init!(X,L)
        0     size=length(X)
        0     h=L/size
        0     for i=0:size-1
        0         if i>floor(size//8) && i<floor(size//2)+floor(size//8)
        0             X[i+1]=1.-2*(i-floor(size/8))*h/L;
        -         else
        0             X[i+1]=0.0
        -         end
        -     end
        - end
        - 
        - 
        - 
        - # proc[1-5]! functions make the same computation, with different programing
        - # styles.
        - 
        - function proc1!(X::Array{Float64,1},Y::Array{Float64,1},niter::Int)
        -  
        0     s=0.0
        0     for it=1:niter
        0         s=dot(X,Y)
        0         X,Y=Y,X
        -     end
        0     s
        - end
        - function proc2!(X::Array{Float64,1},Y::Array{Float64,1},niter::Int)
        0     const size=length(X)
        0     s=0.0
        0     for it=1:niter
        0         s=0.0
        0         @simd for i= 1:size
        0             s+=X[i]*Y[i]
        -         end
        0         X,Y=Y,X
        -     end
        0     s
        - end
        - function proc3!(X::Array{Float64,1},Y::Array{Float64,1},niter::Int)
        0     const size=length(X)
        0     s=0.0
        0     for it=1:niter
        0         s= sum(X.*Y)
        0         X,Y=Y,X
        -     end
        0     s
        - end
        - # measure as precisely as possible the execution time for a given
        - # p= proc[1-5]!
        - function test(p,X::Array{Float64,1},Y::Array{Float64,1},nit::Int)
        -    
  3527801     niter=nit
        0     Init!(X,1.)
        0     Init!(Y,1.)
        -  
        0     p(X,Y,niter)
        0     T=0.
        0     while true
        0         Init!(X,1.)
        0         Init!(Y,1.)
        0         t1 = time_ns()
        0         p(X,Y,niter)
        0         t = (time_ns() -t1)/niter
        0         if abs(t-T)/t<0.025
        0             break
        -     else
        0             T=t
        0             if niter> 150000
        0                 error("too many iterations",niter)
        -             else
        0                 niter*=2
        -             end
        -     end
        -     
        - end
        0     T,niter
        - end
        - 
        - # computation starts here:
        - size=16
        - sizemax=10^5
        - const niter=2
        - while size<sizemax
   148242     println("size: ",size)
  1062984     X=Array{Float64}(size)
  1049840     Y=Array{Float64}(size)
      208     tbest=10.^29
        0     best=0
        0     t=0.0
     1456     for p= [proc1!,proc2!,proc3!]
     1248         t,it=test(p,X,Y,niter)
      624         if t<tbest
      208             tbest=t
        0             best=p
        -         end
  1160950         println(p," : t= ",t," nano-seconds ")
        -     end
        - 
      160     nflops=size*4
    18364     flops=10^9*nflops/tbest
   411776     println("\nbest: ",best)
   106216     println("nb. flops (best): ",nflops, ", Gflops/s: ",flops/10^9)
     1456     println("-------")
        -     
      144     size*=2
        0     println()
        - end
        - 
