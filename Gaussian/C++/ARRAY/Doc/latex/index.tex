\hypertarget{index_Introduction}{}\section{Introduction}\label{index_Introduction}
Array is a template class of... arrays with the following properties\+:


\begin{DoxyItemize}
\item Any type of data can be stored (but the data type must provide the arithmetic operations
\begin{DoxyItemize}
\item -\/ $\ast$ / and -\/may be-\/ other features).
\end{DoxyItemize}
\end{DoxyItemize}

Actually we have in mind to store int, float double, long int and so on, but this not limitative.


\begin{DoxyItemize}
\item Dimensions are limited to 4.
\item The indexation can be row major (like in C) or column major (like in Fortran)
\item Indexes can be in any relative integer interval, for any dimension.
\end{DoxyItemize}\hypertarget{index_namespace}{}\section{namespace}\label{index_namespace}
Array objects belong to the namespace\+: \hyperlink{namespaceArrays}{Arrays}.\hypertarget{index_Warning}{}\section{Warning}\label{index_Warning}
Array class uses a macro defined in \char`\"{}\+Macro\+Restrict.\+hpp\char`\"{}. You must define G\+C\+C in your compiler options if you use g++ or I\+C\+C if you use the Intel icc compiler, or C\+L\+A\+N\+G if you use clang++ . If you use an other compiler, you must adapt the macro. The macro defines how to treat the \char`\"{}\+Restrict\char`\"{} keyword which defines restricted pointers.\hypertarget{index_Instantiation}{}\section{Instantiation}\label{index_Instantiation}

\begin{DoxyItemize}
\item Doing something like\+:

Array$<$double,3$>$ C(Range(-\/3,4),100,Range(20,100))

will create an Array C, with a C-\/like indexation. First index will be in \mbox{[}-\/3,4\mbox{[}, second index in \mbox{[}0,100\mbox{[} and the third one in \mbox{[}20,100\mbox{[}.
\item Doing\+:

Array$<$double,3,\+F\+Engine$>$ C(Range(-\/3,4),100,Range(20,100))

will create an Array F, with a Fortran-\/like indexation. First index will be in \mbox{[}-\/3,4\mbox{]}, second index in \mbox{[}1,100\mbox{]} and the third one in \mbox{[}20,100\mbox{]}.
\begin{DoxyItemize}
\item Note that the index bounds (defined by Range()) do not behave the same way in C-\/like Array and in Fortran-\/like Array!
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{index_Methods}{}\section{Methods}\label{index_Methods}

\begin{DoxyItemize}
\item Operations between arrays\+:

=, += , -\/=

Example\+:

Array$<$double,3,\+F\+Engine$>$ C((Range(-\/3,4),100,Range(20,100)),D(Range(-\/3,4),100,Range(20,100))

C+=D

But both operands must share the same pattern (same bounds of indices, same indexation).
\item Operations with scalars\+: =, += , -\/=, $\ast$= /=
\end{DoxyItemize}

Example\+: C+=1; D=0;


\begin{DoxyItemize}
\item Indexation\+:
\end{DoxyItemize}

Any n dimensional Array has the operator (i,...in); example\+:

s=A(i,j) ; A(i,j)=1.;


\begin{DoxyItemize}
\item Getting the bounds of an index\+:
\end{DoxyItemize}

A.\+mins(i) and A.\+maxs(i) return the lower and upper bound of index i.\hypertarget{index_Iterator}{}\section{Iterator}\label{index_Iterator}
Array objects define an iterator; example\+:

Array$<$double,3$>$ C(Range(-\/3,4),100,Range(20,100))

for(auto I=C.\+begin();I!=C.\+end();I++) \textbackslash{}$\ast$\+I=4;\hypertarget{index_Data}{}\section{Data}\label{index_Data}
Method data() returns a pointer to the begining of the datas of an Array. Note that the storage is continuous in an Array.\hypertarget{index_cycle}{}\section{cycle}\label{index_cycle}
For time steping schemes, it is often very useful to permute the content of \hyperlink{namespaceArrays}{Arrays}. Given Array\textquotesingle{}s A,B,C\+:

A.\+cycle(\+B) permutes the datas of A and B.

A.\+cycle(\+B,\+C) make a circular permutation of contents of A, B and C.

These are permutation of datas, not a copy !\hypertarget{index_Slices}{}\section{Slices}\label{index_Slices}
For C-\/like and Fortran-\/like Array\textquotesingle{}s, we define \char`\"{}natural\char`\"{} slices\+: that is to say slices along the fastest varying coordinate\+:

for example, with a 2 dimensional C-\/like Array, we can get slices which are lines, and with Fortran like \hyperlink{namespaceArrays}{Arrays}, slices wich are columns.

A slice is a (n-\/1) dimensional vue of a n dimensional Array, along the last coordinate for Fortran-\/like \hyperlink{namespaceArrays}{Arrays}, and along the first one with C-\/like \hyperlink{namespaceArrays}{Arrays}.

N\+O D\+A\+T\+A I\+S C\+O\+P\+I\+E\+D! We only build a vue.

Note that it is possible to chain slices for example to get a 1 dimensional Array from a 4 dimensional one.\hypertarget{index_Apply_a_function}{}\section{Apply\+\_\+a\+\_\+function}\label{index_Apply_a_function}
You can apply a function to a whole array. Example\+:

Array$<$double,3,3$>$ X; X.\+apply\+Fonc$<$sin$>$();

You can use any function of yours, but it must be compatible with the model\+:

T function(\+T x)

where T is the type of what is stored in the Array.\hypertarget{index_Adoption}{}\section{Adoption}\label{index_Adoption}
Let $\ast$\+\_\+x be a C vector. We can create an Array A which \char`\"{}adopts\char`\"{} \+\_\+x\+: that is to say in the new Array created,

we will have x= \+\_\+x.

In this case, x (thus xc) will not be deleted when A will be deleted.

Constructors are\+:

\hyperlink{Array__Constructors__RangeBased__NotSafe_8hpp_a5eab639d9e13b4310ee35829a788598b}{Array(\+Range R0,\+T $\ast$\+\_\+x)} in 1d

\hyperlink{Array__Constructors__RangeBased__NotSafe_8hpp_a101a96449298f36a34a256bdee252c28}{Array(\+Range R0,\+Range R1,\+T $\ast$\+\_\+x)} in 2d

and so on.

The range objects R0, R1,... must decribe an object of the same size as xc.

So, these constructors are definitively not safe! (this is for adults programmers only \+:-\/) ).\hypertarget{index_Resizing}{}\section{Resizing}\label{index_Resizing}
Resizing an Array with A.\+resize( ) is possible (arguments are Range objects).

All datas are lost!\hypertarget{index_DEBUG}{}\section{D\+E\+B\+U\+G}\label{index_DEBUG}
If D\+E\+B\+U\+G is defined, Array perform bounds check for indices (and other verifications at run time). In this case, the code will be slow! 